{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/ (unsupported edge import stream)"],"sourcesContent":["__turbopack_context__.n(__import_unsupported(`stream`));\n"],"names":[],"mappings":"AAAA,sBAAsB,CAAC,CAAC,qBAAqB,CAAC,MAAM,CAAC"}},
    {"offset": {"line": 36, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/ (unsupported edge import crypto)"],"sourcesContent":["__turbopack_context__.n(__import_unsupported(`crypto`));\n"],"names":[],"mappings":"AAAA,sBAAsB,CAAC,CAAC,qBAAqB,CAAC,MAAM,CAAC"}},
    {"offset": {"line": 41, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/middleware.ts"],"sourcesContent":["// middleware.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport jwt from 'jsonwebtoken';\n\ninterface TokenPayload {\n  userId: string;\n  role: 'buyer' | 'seller' | 'admin';\n}\n\nexport async function middleware(request: NextRequest) {\n  console.log('Middleware triggered:', request.nextUrl.pathname);\n  const { pathname } = request.nextUrl;\n  \n  // Get token from cookies\n  const token = request.cookies.get('token')?.value;\n  \n  // Public routes that don't require authentication\n  const publicRoutes = ['/', '/login', '/register'];\n  const isPublicRoute = publicRoutes.some(route => pathname === route);\n  \n  // Auth routes that authenticated users shouldn't access\n  const authRoutes = ['/login', '/register'];\n  const isAuthRoute = authRoutes.includes(pathname);\n  console.log(isAuthRoute + \" \" + token);\n  \n  // If accessing auth routes and already authenticated, redirect to appropriate dashboard\n  if (token) { //isAuthRoute &&\n    try {\n      const decoded = jwt.verify(token, process.env.JWT_SECRET!) as TokenPayload;\n      const redirectMap = {\n        admin: '/admin/dashboard',\n        seller: '/seller/dashboard',\n        buyer: '/buyer/dashboard',\n      };\n      return NextResponse.redirect(new URL(redirectMap[decoded.role], request.url));\n    } catch (error) {\n      // Invalid token, allow access to auth routes\n      return NextResponse.next();\n    }\n  }\n  \n  // If accessing public routes, allow\n  if (isPublicRoute) {\n    return NextResponse.next();\n  }\n  \n  // Protected routes require authentication\n  if (!token) {\n    return NextResponse.redirect(new URL('/login', request.url));\n  }\n  \n  // Verify token and check role-based access\n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as TokenPayload;\n    const userRole = decoded.role;\n    \n    // Role-based route protection\n    \n    // Admin-only routes\n    if (pathname.startsWith('/admin')) {\n      if (userRole !== 'admin') {\n        return NextResponse.redirect(new URL('/unauthorized', request.url));\n      }\n    }\n    \n    // Seller-only routes\n    if (pathname.startsWith('/seller')) {\n      if (userRole !== 'seller') {\n        return NextResponse.redirect(new URL('/unauthorized', request.url));\n      }\n    }\n    \n    // Buyer-only routes\n    if (pathname.startsWith('/buyer')) {\n      if (userRole !== 'buyer') {\n        return NextResponse.redirect(new URL('/unauthorized', request.url));\n      }\n    }\n    \n    // Old /dashboard route - redirect to role-specific dashboard\n    if (pathname === '/dashboard' || pathname.startsWith('/dashboard/')) {\n      const redirectMap = {\n        admin: '/admin/dashboard',\n        seller: '/seller/dashboard',\n        buyer: '/buyer/dashboard',\n      };\n      return NextResponse.redirect(new URL(redirectMap[userRole], request.url));\n    }\n    \n    // Allow access if all checks pass\n    return NextResponse.next();\n    \n  } catch (error) {\n    // Invalid token, redirect to login\n    const response = NextResponse.redirect(new URL('/login', request.url));\n    response.cookies.delete('token');\n    return response;\n  }\n}\n\nexport const config = {\n  matcher: [\n    '/admin/:path*',\n    '/seller/:path*',\n    '/buyer/:path*',\n    '/dashboard/:path*',\n    '/login',\n    '/register',\n  ],\n};"],"names":[],"mappings":"AAAA,gBAAgB;;;;;AAChB;AAAA;AACA;;;AAOO,eAAe,WAAW,OAAoB;IACnD,QAAQ,GAAG,CAAC,yBAAyB,QAAQ,OAAO,CAAC,QAAQ;IAC7D,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ,OAAO;IAEpC,yBAAyB;IACzB,MAAM,QAAQ,QAAQ,OAAO,CAAC,GAAG,CAAC,UAAU;IAE5C,kDAAkD;IAClD,MAAM,eAAe;QAAC;QAAK;QAAU;KAAY;IACjD,MAAM,gBAAgB,aAAa,IAAI,CAAC,CAAA,QAAS,aAAa;IAE9D,wDAAwD;IACxD,MAAM,aAAa;QAAC;QAAU;KAAY;IAC1C,MAAM,cAAc,WAAW,QAAQ,CAAC;IACxC,QAAQ,GAAG,CAAC,cAAc,MAAM;IAEhC,wFAAwF;IACxF,IAAI,OAAO;QACT,IAAI;YACF,MAAM,UAAU,6IAAA,CAAA,UAAG,CAAC,MAAM,CAAC,OAAO,QAAQ,GAAG,CAAC,UAAU;YACxD,MAAM,cAAc;gBAClB,OAAO;gBACP,QAAQ;gBACR,OAAO;YACT;YACA,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,WAAW,CAAC,QAAQ,IAAI,CAAC,EAAE,QAAQ,GAAG;QAC7E,EAAE,OAAO,OAAO;YACd,6CAA6C;YAC7C,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;QAC1B;IACF;IAEA,oCAAoC;IACpC,IAAI,eAAe;QACjB,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;IAC1B;IAEA,0CAA0C;IAC1C,IAAI,CAAC,OAAO;QACV,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;IAC5D;IAEA,2CAA2C;IAC3C,IAAI;QACF,MAAM,UAAU,6IAAA,CAAA,UAAG,CAAC,MAAM,CAAC,OAAO,QAAQ,GAAG,CAAC,UAAU;QACxD,MAAM,WAAW,QAAQ,IAAI;QAE7B,8BAA8B;QAE9B,oBAAoB;QACpB,IAAI,SAAS,UAAU,CAAC,WAAW;YACjC,IAAI,aAAa,SAAS;gBACxB,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,iBAAiB,QAAQ,GAAG;YACnE;QACF;QAEA,qBAAqB;QACrB,IAAI,SAAS,UAAU,CAAC,YAAY;YAClC,IAAI,aAAa,UAAU;gBACzB,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,iBAAiB,QAAQ,GAAG;YACnE;QACF;QAEA,oBAAoB;QACpB,IAAI,SAAS,UAAU,CAAC,WAAW;YACjC,IAAI,aAAa,SAAS;gBACxB,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,iBAAiB,QAAQ,GAAG;YACnE;QACF;QAEA,6DAA6D;QAC7D,IAAI,aAAa,gBAAgB,SAAS,UAAU,CAAC,gBAAgB;YACnE,MAAM,cAAc;gBAClB,OAAO;gBACP,QAAQ;gBACR,OAAO;YACT;YACA,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,WAAW,CAAC,SAAS,EAAE,QAAQ,GAAG;QACzE;QAEA,kCAAkC;QAClC,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;IAE1B,EAAE,OAAO,OAAO;QACd,mCAAmC;QACnC,MAAM,WAAW,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;QACpE,SAAS,OAAO,CAAC,MAAM,CAAC;QACxB,OAAO;IACT;AACF;AAEO,MAAM,SAAS;IACpB,SAAS;QACP;QACA;QACA;QACA;QACA;QACA;KACD;AACH"}}]
}